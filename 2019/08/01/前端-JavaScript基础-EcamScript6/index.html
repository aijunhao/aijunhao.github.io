<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>前端-JavaScript基础-二刷ES | Hello, I&#39;m Junhao Ai.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言 学习资料 ES 版本   ES5 基础 严格模式 JSON 对象 Object 拓展 Object.create() Object.defineProperties()   数组拓展 Function 拓展   阮一峰 ES6 基础 let、var、const let 作用 特点 应用 const   变量的解构赋值 普通赋值 数组的解构赋值 默认值 对象的解构赋值 数组与对象   字符">
<meta name="keywords" content="JavaScript,前端,EcamScript6">
<meta property="og:type" content="article">
<meta property="og:title" content="前端-JavaScript基础-二刷ES">
<meta property="og:url" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/index.html">
<meta property="og:site_name" content="Hello, I&#39;m Junhao Ai.">
<meta property="og:description" content="前言 学习资料 ES 版本   ES5 基础 严格模式 JSON 对象 Object 拓展 Object.create() Object.defineProperties()   数组拓展 Function 拓展   阮一峰 ES6 基础 let、var、const let 作用 特点 应用 const   变量的解构赋值 普通赋值 数组的解构赋值 默认值 对象的解构赋值 数组与对象   字符">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/Object.JPG">
<meta property="og:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/Object.defineProperties.JPG">
<meta property="og:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/call.JPG">
<meta property="og:image" content="http://yoursite.com/前端-JavaScript基础-EcamScript6/proto.JPG">
<meta property="og:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/Promise.jpg">
<meta property="og:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/map.JPG">
<meta property="og:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/map2.JPG">
<meta property="og:updated_time" content="2019-08-25T07:02:03.135Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端-JavaScript基础-二刷ES">
<meta name="twitter:description" content="前言 学习资料 ES 版本   ES5 基础 严格模式 JSON 对象 Object 拓展 Object.create() Object.defineProperties()   数组拓展 Function 拓展   阮一峰 ES6 基础 let、var、const let 作用 特点 应用 const   变量的解构赋值 普通赋值 数组的解构赋值 默认值 对象的解构赋值 数组与对象   字符">
<meta name="twitter:image" content="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/Object.JPG">
  
    <link rel="alternate" href="/atom.xml" title="Hello, I&#39;m Junhao Ai." type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hello, I&#39;m Junhao Ai.</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-前端-JavaScript基础-EcamScript6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/01/前端-JavaScript基础-EcamScript6/" class="article-date">
  <time datetime="2019-08-01T08:59:13.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端-JavaScript基础-二刷ES
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- TOC -->
<ul>
<li><a href="#前言">前言</a><ul>
<li><a href="#学习资料">学习资料</a></li>
<li><a href="#es-版本">ES 版本</a></li>
</ul>
</li>
<li><a href="#es5-基础">ES5 基础</a><ul>
<li><a href="#严格模式">严格模式</a></li>
<li><a href="#json-对象">JSON 对象</a></li>
<li><a href="#object-拓展">Object 拓展</a><ul>
<li><a href="#objectcreate">Object.create()</a></li>
<li><a href="#objectdefineproperties">Object.defineProperties()</a></li>
</ul>
</li>
<li><a href="#数组拓展">数组拓展</a></li>
<li><a href="#function-拓展">Function 拓展</a></li>
</ul>
</li>
<li><a href="#阮一峰-es6-基础">阮一峰 ES6 基础</a><ul>
<li><a href="#letvarconst">let、var、const</a><ul>
<li><a href="#let-作用">let 作用</a></li>
<li><a href="#特点">特点</a></li>
<li><a href="#应用">应用</a></li>
<li><a href="#const">const</a></li>
</ul>
</li>
<li><a href="#变量的解构赋值">变量的解构赋值</a><ul>
<li><a href="#普通赋值">普通赋值</a></li>
<li><a href="#数组的解构赋值">数组的解构赋值</a></li>
<li><a href="#默认值">默认值</a></li>
<li><a href="#对象的解构赋值">对象的解构赋值</a><ul>
<li><a href="#数组与对象">数组与对象</a></li>
</ul>
</li>
<li><a href="#字符串的解构赋值">字符串的解构赋值</a></li>
<li><a href="#函数参数的解构赋值">函数参数的解构赋值</a></li>
<li><a href="#解构赋值的圆括号问题">解构赋值的圆括号问题</a></li>
<li><a href="#解构赋值的用途">解构赋值的用途</a></li>
</ul>
</li>
<li><a href="#字符串的拓展">字符串的拓展</a><ul>
<li><a href="#模板字符串">模板字符串</a></li>
<li><a href="#字符串方法">字符串方法</a></li>
</ul>
</li>
<li><a href="#数值的拓展">数值的拓展</a><ul>
<li><a href="#进制">进制</a></li>
<li><a href="#numberisnan">Number.isNaN()</a></li>
<li><a href="#numberparseint-和-numberparsefloat">Number.parseInt() 和 Number.parseFloat()</a></li>
<li><a href="#numberisinteger">Number.isInteger()</a></li>
<li><a href="#numberepsilon">Number.EPSILON</a></li>
</ul>
</li>
<li><a href="#函数的拓展">函数的拓展</a><ul>
<li><a href="#函数参数的默认值">函数参数的默认值</a></li>
<li><a href="#函数的-length-属性">函数的 length 属性</a></li>
<li><a href="#作用域">作用域</a></li>
<li><a href="#rest-参数">rest 参数</a></li>
<li><a href="#箭头函数">箭头函数</a><ul>
<li><a href="#注意事项">注意事项</a></li>
<li><a href="#this-理解">this 理解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#数组的拓展">数组的拓展</a><ul>
<li><a href="#拓展运算符">拓展运算符</a><ul>
<li><a href="#应用-1">应用</a></li>
</ul>
</li>
<li><a href="#arrayfrom">Array.from()</a></li>
<li><a href="#arrayof">Array.of()</a></li>
<li><a href="#copywithin">copyWithin()</a></li>
<li><a href="#find-和-findindex">find() 和 findIndex()</a></li>
<li><a href="#fill">fill()</a></li>
<li><a href="#entrieskeysvalues">entries()、keys()、values()</a></li>
<li><a href="#includes">includes()</a></li>
</ul>
</li>
<li><a href="#对象的拓展">对象的拓展</a><ul>
<li><a href="#属性和方法的简写">属性和方法的简写</a></li>
<li><a href="#属性名表达式">属性名表达式</a></li>
<li><a href="#objectis">Object.is()</a></li>
<li><a href="#objectassign">Object.assign()</a></li>
<li><a href="#__proto__"><code>__proto__</code></a></li>
<li><a href="#objectsetprototypeof">Object.setPrototypeOf()</a></li>
<li><a href="#objectgetprototypeof">Object.getPrototypeOf()</a></li>
<li><a href="#objectcreate-1">Object.create()</a></li>
<li><a href="#对象的拓展运算符与解构">对象的拓展运算符与解构</a></li>
<li><a href="#深复制">深复制</a></li>
</ul>
</li>
<li><a href="#promise-对象">Promise 对象</a><ul>
<li><a href="#callback-hell-回调地狱">callback hell 回调地狱</a></li>
<li><a href="#promise-含义">Promise 含义</a></li>
<li><a href="#thencatch">then()、catch()</a></li>
<li><a href="#promiseall">Promise.all()</a></li>
<li><a href="#promiserace">Promise.race()</a></li>
<li><a href="#promiseresolve">Promise.resolve()</a></li>
<li><a href="#promisereject">Promise.reject()</a></li>
<li><a href="#promisedone">Promise.done()</a></li>
<li><a href="#promisefinally">Promise.finally()</a></li>
<li><a href="#案例">案例</a><ul>
<li><a href="#案例将函数封装成-promise-对象">案例：将函数封装成 <code>Promise</code> 对象</a></li>
<li><a href="#案例nodejs-中-promise-读取文件数据">案例：Node.js 中 Promise 读取文件数据</a></li>
<li><a href="#案例前端请求数据时的-promise">案例：前端请求数据时的 Promise</a></li>
<li><a href="#案例nodejs-调用-mongoose-时的-promise">案例：Node.js 调用 Mongoose 时的 promise</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#symbol">Symbol</a><ul>
<li><a href="#作为属性名的-symbol">作为属性名的 Symbol</a></li>
<li><a href="#属性名的遍历">属性名的遍历</a></li>
<li><a href="#symbolfor">Symbol.for()</a></li>
<li><a href="#symbolkeyfor">Symbol.keyFor()</a></li>
</ul>
</li>
<li><a href="#set-数据结构">Set 数据结构</a><ul>
<li><a href="#set-实例的属性和方法">Set 实例的属性和方法</a></li>
<li><a href="#遍历操作">遍历操作</a></li>
</ul>
</li>
<li><a href="#map-数据结构">Map 数据结构</a><ul>
<li><a href="#map-键的引用">Map 键的引用</a></li>
<li><a href="#map-实例的属性和方法">Map 实例的属性和方法</a></li>
<li><a href="#遍历操作-1">遍历操作</a></li>
<li><a href="#map-与-其他数据类型转化">Map 与 其他数据类型转化</a><ul>
<li><a href="#map-与数组互相转化">Map 与数组互相转化</a></li>
<li><a href="#map-与对象">Map 与对象</a></li>
<li><a href="#map-与-json">Map 与 JSON</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#iterator-和-for--of-循环">Iterator 和 for … of 循环</a><ul>
<li><a href="#for--of">for … of</a><ul>
<li><a href="#数组">数组</a></li>
<li><a href="#set--map">Set / Map</a></li>
<li><a href="#类数组对象">类数组对象</a></li>
<li><a href="#对象">对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#class-类">Class （类）</a><ul>
<li><a href="#严格模式-1">严格模式</a></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#类的实例对象">类的实例对象</a></li>
<li><a href="#class-表达式">Class 表达式</a></li>
<li><a href="#不存在变量提升">不存在变量提升</a></li>
<li><a href="#私有方法">私有方法</a></li>
<li><a href="#私有属性">私有属性</a></li>
<li><a href="#this-指向">this 指向</a></li>
<li><a href="#getter-和-setter">getter 和 setter</a></li>
<li><a href="#静态方法">静态方法</a></li>
<li><a href="#静态属性和实例属性">静态属性和实例属性</a></li>
</ul>
</li>
<li><a href="#class-的继承">Class 的继承</a><ul>
<li><a href="#objectgetprototypeof-1">Object.getPrototypeOf()</a></li>
<li><a href="#super-关键字">super 关键字</a></li>
<li><a href="#类的-prototype-属性和-__proto__-属性">类的 prototype 属性和 <code>__proto__</code> 属性</a></li>
</ul>
</li>
<li><a href="#module">Module</a><ul>
<li><a href="#严格模式-2">严格模式</a></li>
<li><a href="#export-命令">export 命令</a></li>
<li><a href="#export-default-命令">export default 命令</a></li>
<li><a href="#import-命令">import 命令</a></li>
<li><a href="#export-和-import--复合写法">export 和 import  复合写法</a></li>
<li><a href="#node-加载">Node 加载</a><ul>
<li><a href="#import-命令加载-commonjs-模块">import 命令加载 CommonJS 模块</a></li>
<li><a href="#require-命令加载-es6-模块">require 命令加载 ES6 模块</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#拓展">拓展</a><ul>
<li><a href="#-objectis">== 、===、Object.is()</a></li>
<li><a href="#数组去重">数组去重</a><ul>
<li><a href="#set--拓展运算符">Set + 拓展运算符</a></li>
<li><a href="#set--arrayfrom">Set + Array.from()</a></li>
</ul>
</li>
<li><a href="#数组交并集">数组交并集</a></li>
<li><a href="#原型">原型</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打卡，二刷。</p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p>阮一峰 <code>ES6</code> 教材：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p>
<p>尚硅谷 <code>ES</code> 视频教程：<a href="http://www.atguigu.com/" target="_blank" rel="noopener">http://www.atguigu.com/</a></p>
<h3 id="ES-版本"><a href="#ES-版本" class="headerlink" title="ES 版本"></a>ES 版本</h3><p><code>ES5</code> ：09年发布</p>
<p><code>ES6</code> ：15年发布，又称 <code>ES2015</code> ，主流 <code>ES</code>。</p>
<p><code>ES7</code> ：16年发布，新增内容主要是草案，尚未纳入正式 <code>ES</code> 标准，以及 <code>ES8</code> 也是，所以，重点是 <code>ES6</code> 。</p>
<hr>
<h2 id="ES5-基础"><a href="#ES5-基础" class="headerlink" title="ES5 基础"></a>ES5 基础</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ol>
<li><p>理解:</p>
<p> 除了正常运行模式(混杂模式)，ES5 添加了第二种运行模式：”严格模式”（strict mode）。</p>
<p> 顾名思义，这种模式使得 Javascript 在更严格的语法条件下运行</p>
</li>
<li><p>目的/作用</p>
<p> 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</p>
<p> 消除代码运行的一些不安全之处，为代码的安全运行保驾护航</p>
<p> 为未来新版本的 Javascript 做好铺垫</p>
</li>
<li><p>使用</p>
<p> 在全局或函数的第一条语句定义为: ‘use strict’;</p>
<p> 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用</p>
</li>
<li><p>语法和行为改变</p>
<p> 必须用 var 声明变量</p>
<p> 禁止自定义的函数中的 this 指向 window</p>
<p> 创建 eval 作用域</p>
<p> 对象不能有重名的属性</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 开启严格模式</span></span></span><br><span class="line"><span class="javascript"><span class="meta">  'use strict'</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 不使用 var 声明变量，严格模式报错，在未开启严格模式时，会自动上升为全局变量</span></span></span><br><span class="line"><span class="javascript">  username = <span class="string">'kobe'</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 正确的声明变量</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> username = <span class="string">'kobe'</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(username)</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义一个构造函数</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.name = name</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.age = age</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 自调用时，this 指向 window, 严格模式报错</span></span></span><br><span class="line"><span class="javascript">  Person(<span class="string">'kobe'</span>, <span class="number">39</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 正确写法</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>)</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">  <span class="comment">// eval() 字符串解析函数，未开启严格模式时，eval 没有私有作用域，str 始终指向外部的 str</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> str = <span class="string">'NBA'</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">eval</span>(<span class="string">'var str = "CBA"; alert(str)'</span>)</span></span><br><span class="line"><span class="javascript">  alert(str)	<span class="comment">// 严格模式：NBA，未开启严格模式：CBA</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><ol>
<li><p>JSON.stringify(obj/arr)：js 对象(数组)转换为 json 对象(数组)</p>
</li>
<li><p>JSON.parse(json)：json 对象(数组)转换为 js 对象(数组)</p>
</li>
</ol>
<h3 id="Object-拓展"><a href="#Object-拓展" class="headerlink" title="Object 拓展"></a>Object 拓展</h3><p><em>ES5给Object扩展了一些静态方法, 常用的 2 个:</em></p>
<h4 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h4><p>Object.create(prototype, [descriptors])</p>
<p>  *<em> 作用: 以指定对象为原型创建新的对象</em></p>
<p>  *<em> 为新的对象指定新的属性, 并对属性进行描述</em></p>
<p>​    <em>- value : 指定值</em></p>
<p>​    <em>- writable : 标识当前属性值是否是可修改的, 默认为 false</em></p>
<p>​    <em>- configurable: 标识当前属性是否可以被删除 默认为 false</em></p>
<p>​    <em>- enumerable：标识当前属性是否能用 for in 枚举 默认为 false</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> obj = &#123; <span class="attr">usernam</span>: <span class="string">'demo'</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> obj1 = &#123;&#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 以 obj 为原型-创建对象</span></span></span><br><span class="line"><span class="javascript">  obj1 = <span class="built_in">Object</span>.create(obj)</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">  <span class="comment">// obj1 = Object.create(obj, , &#123;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//   gender: &#123;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//     value: '男'</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj1)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	新建的对象为空，展开后可以见到 '__proto__' 属性，这是用来读取或设置当前对象的 prototype 对象，ES6 规定，这个属性只在浏览器上必须部署，其他环境不需要且最好不要。</span></span><br><span class="line"><span class="comment">	ES6 建议使用 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）或Object.create()（生成操作）代替 '__proto__' 属性。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/01/前端-JavaScript基础-EcamScript6/Object.JPG" alt="Object.JPG"></p>
<h4 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h4><p>Object.defineProperties(object, descriptors)</p>
<p>​    *<em> 作用 : 为指定对象定义扩展多个属性</em></p>
<p>​    *<em> get ：用来获取当前属性值得回调函数</em></p>
<p>​    *<em> set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值</em></p>
<p>​    *<em> 存取器属性：setter, getter一个用来存值，一个用来取值</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加 存取器 属性 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> obj = &#123; <span class="attr">firstName</span>: <span class="string">'kobe'</span>, <span class="attr">lastName</span>: <span class="string">'bryant'</span> &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.defineProperties(obj, &#123;</span></span><br><span class="line"><span class="undefined">    fullName: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取拓展属性的值，获取拓展属性值的时候 get 方法自动调用</span></span></span><br><span class="line"><span class="undefined">      get() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'get调用'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 监听拓展属性，当拓展属性发生变化时自动调用，会将变化的值作为实参传入到 set 函数</span></span></span><br><span class="line"><span class="undefined">      set(data) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'set调用'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> name = data.split(<span class="string">' '</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.firstName = name[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.lastName = name[<span class="number">1</span>]</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 调用拓展属性 fullName, 此时 get() 方法调用</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj.fullName)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 给拓展属性赋值，调用 set() 方法</span></span></span><br><span class="line"><span class="javascript">  obj.fullName = <span class="string">'tim duncan'</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	使用 Object.defineProperties() 来拓展 obj 的 fullName 属性，get() 存在惰性，只要在需要调用的时候才执行。</span></span><br><span class="line"><span class="comment">	这个新添加的存取器属性如下图，不会出现在对象属性中，并且展开对象后显示省略号，点击省略号后才显示，这也是因为惰性。</span></span><br><span class="line"><span class="comment">	同时，还有一点就是，添加了拓展属性后，出现了 get fullName() &#123;&#125; 和 set fullName(data) &#123;&#125; 这两个方法，添加存取器属性的本质就是调用了这两个方法。代码如下。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> obj = &#123; </span></span><br><span class="line"><span class="javascript">    firstName: <span class="string">'kobe'</span>, </span></span><br><span class="line"><span class="javascript">    lastName: <span class="string">'bryant'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取拓展属性的值，获取拓展属性值的时候 get 方法自动调用</span></span></span><br><span class="line"><span class="undefined">    get fullName() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'get调用'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line"><span class="undefined">    &#125;,  </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听拓展属性，当拓展属性发生变化时自动调用，会将变化的值作为实参传入到 set 函数</span></span></span><br><span class="line"><span class="undefined">    set fullName(data) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'set调用'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> name = data.split(<span class="string">' '</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.firstName = name[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.lastName = name[<span class="number">1</span>]</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj.fullName)</span></span><br><span class="line"><span class="javascript">  obj.fullName = <span class="string">'tim duncan'</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/01/前端-JavaScript基础-EcamScript6/Object.defineProperties.JPG" alt="Object.defineProperties.JPG"></p>
<p>Object.defineProperties() 也可以像 Object.create() 一样使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> obj = &#123; <span class="attr">firstName</span>: <span class="string">'kobe'</span>, <span class="attr">lastName</span>: <span class="string">'bryant'</span> &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.defineProperties(obj, &#123;</span></span><br><span class="line"><span class="undefined">    fullName: &#123;</span></span><br><span class="line"><span class="javascript">      value: <span class="string">'test'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="javascript">  obj.fullName = <span class="string">'tim duncan'</span>	<span class="comment">// 无法修改</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组拓展"><a href="#数组拓展" class="headerlink" title="数组拓展"></a>数组拓展</h3><p><em>1. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标</em></p>
<p><em>2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</em></p>
<p><em>3. Array.prototype.forEach(function(item, index){}) : 遍历数组</em></p>
<p><em>4. Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组，返回加工之后的值</em></p>
<p><em>5. Array.prototype.filter(function(item, index){}) : 遍历过滤出一个新的子数组， 返回条件为true的值</em></p>
<h3 id="Function-拓展"><a href="#Function-拓展" class="headerlink" title="Function 拓展"></a>Function 拓展</h3><p><em>1. Function.prototype.bind(obj) :</em></p>
<p>  *<em> 作用 : 将函数内的 this绑定为 obj , 并将函数返回</em></p>
<p><em>2. 面试题 : 区别 bind() 与 call() 和 apply()? </em></p>
<p>  *<em> 都能指定函数中的 this</em></p>
<p>  *<em> call() / apply() 是立即调用函数</em></p>
<p>  *<em> bind() 是将函数返回，传参方式与 call() 一样，常用于回调函数的 this 绑定</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当一个函数被保存为对象的一个方法时，如果调用表达式包含一个提取属性的动作，那么它就是被当做一个方法来调用，此时的this被绑定到这个对象。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> obj = &#123; </span></span><br><span class="line"><span class="javascript">    username: <span class="string">'kobe'</span>,</span></span><br><span class="line"><span class="javascript">    a: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.username, data)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, data)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 一般调用对象中的方法</span></span></span><br><span class="line"><span class="undefined">  obj.a()</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 将 a 方法绑定 obj 这个对象，这样 a 方法就能用 this 调用 obj 中的属性</span></span></span><br><span class="line"><span class="undefined">  obj.a.call(obj, 123)</span></span><br><span class="line"><span class="undefined">  obj.a.apply(obj, [123])</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  foo.call(obj, 123)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 返回一个函数，没有调用，可以使用变量来接收</span></span></span><br><span class="line"><span class="undefined">  foo.bind(obj, 456)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 返回后直接调用</span></span></span><br><span class="line"><span class="undefined">  foo.bind(obj, 456)()</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 修改回调函数的 this 绑定，原本 setTimeOut 的 this 是 window ，使用 bind 修改成 obj</span></span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span></span><br><span class="line"><span class="undefined">  &#125;.bind(obj), 1000)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/01/前端-JavaScript基础-EcamScript6/call.JPG" alt="call.JPG"></p>
<h2 id="阮一峰-ES6-基础"><a href="#阮一峰-ES6-基础" class="headerlink" title="阮一峰 ES6 基础"></a>阮一峰 ES6 基础</h2><h3 id="let、var、const"><a href="#let、var、const" class="headerlink" title="let、var、const"></a>let、var、const</h3><h4 id="let-作用"><a href="#let-作用" class="headerlink" title="let 作用"></a>let 作用</h4><p>与var类似, 用于声明一个变量</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>不会预处理, 不存在提升</p>
<p> <strong>变量提升与预处理</strong>：js和其他语言一样，都要经历编译和执行阶段。而 js 在编译阶段（预处理）的时候，会搜集所有的 <code>变量声明</code> 和 <code>函数声明</code> 并且<strong>将声明提升到全局顶部</strong>（没有定义），当出现同名声明冲突时，函数将覆盖变量，而其他的语句都不会改变他们的顺序。</p>
<p> <code>var</code> 声明的变量会出现变量提升，而 <code>let</code> 不可以。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">// ReferenceError 引用错误</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="built_in">console</span>.log(b)		<span class="comment">// undefined 未定义</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var 的预处理代码</span></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line">b = <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能重复声明</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 重复声明 a，不报错</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> a </span><br><span class="line"></span><br><span class="line"><span class="comment">// let 重复声明 b，第二个 b 会报错</span></span><br><span class="line"><span class="keyword">let</span> b </span><br><span class="line"><span class="keyword">let</span> b	<span class="comment">// Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在块作用域内有效</p>
<p> 块级作用域与其他语言中的作用域类似。</p>
<p> 在 <code>ES5</code> 中规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。</p>
<p> <code>ES6</code> 明确允许在块级作用域中声明函数，声明语句的行为类似于 <code>let</code>。</p>
 <font color="red">但是不建议在块级作用域中声明函数，因环境问题，容易报错，建议使用函数表达式的形式。</font>

 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol>
<li>循环遍历加监听</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 var 变量遍历</span></span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]()		<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码中，var 声明的 i 在全局有效，也就是说全局作用域中只有唯一一个 i ，函数表达式中的输出 i 都指向全局，而函数是在调用时候执行，for 循环之后，全局 i 变成 10，a[0]() 调用就是 10。至于 a[i] 中的 i 为什么不是 10？因为这个 i 和全局的 i 是同步变化的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 let 变量遍历</span></span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">a[<span class="number">6</span>]()		<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码中，let 声明的 i 在只在当前一轮的 for 循环中有效，也就是说共有 10 个 i 在 10 个不同的循环作用域中，函数表达式中的输出 i 都指向当前作用域中声明的 i 。</span></span><br><span class="line"><span class="comment">// 注意：理论上说，每一轮重新声明的 i 都应该是 0 ！！！但是在 JS 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮的基础上进行的。</span></span><br></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><code>const</code> 变量，指的是变量指向的内存地址不变，而不是地址中存储的内容不变。其他的基本同 <code>let</code> 。</p>
<p>对于简单数据类型数据（Number、String、Boolean）来说，其内容存储在地址中，等同于常量；而对于对象数组等复杂数据类型，地址中只保存了实际数据的地址指针，<code>const</code> 也只能保证这个指针不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;</span><br><span class="line">foo.a = <span class="number">123</span>			<span class="comment">// 正确</span></span><br><span class="line">foo.b = <span class="number">456</span>			<span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)	<span class="comment">// &#123;a: 123, b: 456&#125;</span></span><br><span class="line"></span><br><span class="line">foo = &#123; <span class="attr">c</span>: <span class="number">789</span> &#125;	<span class="comment">// 错误，指向另一个对象了</span></span><br></pre></td></tr></table></figure>
<p>如果需要让对象也是常量，可以用以下方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冻结对象常量方法</span></span><br><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 冻结当前对象</span></span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="comment">// 遍历并冻结对象类型的属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      constantize( obj[key] )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化对象常量</span></span><br><span class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 冻结 foo 常量</span></span><br><span class="line">constantize(foo)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性，不起作用，严格模式下报错</span></span><br><span class="line">foo.b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo)    <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><p>解构赋值，顾名思义就是解析数组或对象结构并给变量赋值。</p>
<p>解构赋值需要按照一定的模式进行，是一种”模式匹配“，其规则是，只要等号右侧的值不是对象或者数组，就先转为对象，然后根据解构赋值机制进行赋值。<code>undefined</code> 和 <code>null</code> 无法转化成对象，不能进行解构赋值。</p>
<font color="red">解构赋值的复制是浅复制，如果是复合类型的值（数组、对象、函数），那么解构赋值复制的是引用，而不是副本。</font>

<h4 id="普通赋值"><a href="#普通赋值" class="headerlink" title="普通赋值"></a>普通赋值</h4><p>如下，就是等号左边变量，等号右边值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>解构赋值就是在这基础上完成的。</p>
<p>如果解构不成功，即左侧某个位置有变量，右侧对应位置没有值，则该变量为 <code>undefined</code> 。</p>
<p>如果不完全解构，即右侧某个位置有值，左侧对应位置没有声明变量，则该项不赋值。</p>
<h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>数组的解构赋值，等号右边是数组，左边也要是数组，按位置赋值。</p>
<ol>
<li>给变量赋值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值，结构数组 [1, 2, 3]，给左边数组对应位上的变量赋值</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c, d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)		<span class="comment">// 1 2 3 undefined</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>给数组赋值。</p>
<p> 需要使用 <code>...</code> 拓展运算法，并且拓展运算符只能写在最后一项变量中，并且只能给一个数组赋值，因为目标数组长度无法确定。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [...a] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [b, ...c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(b, c)	<span class="comment">// 1 [2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许存在默认值，都是使用赋值符号表示，这里用数据解构来演示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = []</span><br><span class="line"><span class="built_in">console</span>.log(foo)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>ES6</code> 内部使用严格相等运算符（===）判断一个位置是否有值，只有严格等于 <code>undefined</code> ，默认值才能生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应为使用 undefined 。</span></span><br><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [<span class="literal">undefined</span>]</span><br><span class="line"><span class="built_in">console</span>.log(foo)	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应为使用 'undefined' 字符串。</span></span><br><span class="line"><span class="keyword">let</span> [foo2 = <span class="literal">true</span>] = [<span class="string">'undefined'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo2, foo2)	<span class="comment">// string undefined</span></span><br></pre></td></tr></table></figure>
<p>默认值也可以引用解构赋值中已声明的变量（就是顺序在该变量之前），并且随着该变量的变化而变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = []		<span class="comment">// x = 1, y = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>]	<span class="comment">// x = 2, y = 2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = []		<span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>对象的解构赋值，等号右边是对象，左边也要是对象，按属性名赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; 对象属性名: 变量 &#125; 冒号左右侧相同时可以缩写为一个。</span></span><br><span class="line"><span class="comment">// 对象的解构赋值机制是先找到同名属性，然后赋值给对应的变量，被赋值这是冒号右侧的变量。</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line">foo		<span class="comment">// 'aaa'</span></span><br><span class="line">bar 	<span class="comment">// 'bbb'</span></span><br></pre></td></tr></table></figure>
<h5 id="数组与对象"><a href="#数组与对象" class="headerlink" title="数组与对象"></a>数组与对象</h5><p>因为数组的本质是特殊的对象，所以可以将数组解构为对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="number">0</span>: first, <span class="number">1</span>: secode &#125; = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(first, secode)</span><br></pre></td></tr></table></figure>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串被解构时被转换成一个类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">length</span>: len &#125; = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e)		<span class="comment">// h e l l o</span></span><br><span class="line"><span class="built_in">console</span>.log(len)				<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>如下，函数参数是一个数组的时候，传入参数后就被解构成变量 <code>x</code>  和 <code>y</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add([<span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<p>函数参数的解构赋值中，有一点需要特别注意，就是函数参数的默认值和解构默认值。<font color="red">只要抓住解构赋值使用 “ = ” 进行设置默认值就行。</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)     <span class="comment">// [3，8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;)          <span class="comment">// [3，0]</span></span><br><span class="line">move(&#123;&#125;)                <span class="comment">// [0, 0]</span></span><br><span class="line">move()                  <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">// 函数参数的默认值是空对象 &#123;&#125;，解构赋值的默认值 x = 0, y = 0，当解构失败时候使用默认值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)     <span class="comment">// [3，8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;)          <span class="comment">// [3，undefined]</span></span><br><span class="line">move(&#123;&#125;)                <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move()                  <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="comment">// 函数参数的默认值是 &#123; x: 0, y: 0&#125;，解构赋值 x, y 没有默认值，当且仅当调用函数没有传入参数时才取到函数默认值</span></span><br></pre></td></tr></table></figure>
<h4 id="解构赋值的圆括号问题"><a href="#解构赋值的圆括号问题" class="headerlink" title="解构赋值的圆括号问题"></a>解构赋值的圆括号问题</h4><p>在解构赋值中不建议使用圆括号，容易导致解构歧义。</p>
<p>不能使用圆括号的情况：</p>
<ol>
<li><p>变量声明语句。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>]		<span class="comment">// 报错，这个语句包括了声明和赋值，声明部分报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数。</p>
<p> 函数参数也属于变量声明，因此不能使用圆括号。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(x</span>)])	// 看着就容易出问题…</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值语句的模式。</p>
<p> 之前说解构赋值是 “模式匹配” ，需要等号两边模式相同（数组、对象）才能正常执行，一旦模式部分出现了圆括号，就容易出错。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;		<span class="comment">// 模式不匹配， () = &#123;&#125; 错误</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;]		<span class="comment">// 模式不匹配， () = &#123;&#125; 错误</span></span><br><span class="line"></span><br><span class="line">[(b)] = [<span class="number">3</span>]		<span class="comment">// 正确，模式是取数组的第一个成员，与圆括号无关，但是最好不要这样用！！！</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (b) &#125; = &#123;&#125;)		<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h4><ol>
<li><p>交换变量的值。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]		<span class="comment">// 简化了使用第三中间变量的步奏，简洁易懂</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从函数返回多个值。</p>
<p> 传统的函数中，只能返回一个值，或者是一个数组、对象。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example()		<span class="comment">// 返回值是一个数组，利用解构赋值变成一堆单独的变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的定义。</p>
<p> 可以设置函数参数形式以及是否有默认值。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])		<span class="comment">// 参数是一个有序的数组</span></span><br><span class="line">                       </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; x, y, z &#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span> &#125;)		<span class="comment">// 参数是无序的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取 JSON 数据</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    status: <span class="string">"OK"</span>,</span><br><span class="line">    data: [<span class="number">123</span>, <span class="number">456</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData</span><br><span class="line"></span><br><span class="line">id		<span class="comment">// 1</span></span><br><span class="line">status	<span class="comment">// "OK"</span></span><br><span class="line">number	<span class="comment">// [123, 456]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历有 <code>Iterator</code> 接口的对象。</p>
</li>
<li>获取模块的指定方法。</li>
</ol>
<h3 id="字符串的拓展"><a href="#字符串的拓展" class="headerlink" title="字符串的拓展"></a>字符串的拓展</h3><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>使用反引号来代替单引号/双引号。可以当做普通字符串使用，也可以定义多行字符串，或者嵌入变量。</p>
<ol>
<li><p>多行文本</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义多行文本，会保留其格式。所有空格缩进都会被保留。</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`123</span></span><br><span class="line"><span class="string">  456`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套变量</p>
<p> 变量名需要写在 <code>${}</code> 的大括号中，可以使任意 <code>JS</code> 表达式，支持运算和对象属性。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 $&#123; 变量名 &#125; 来嵌套变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`你好，<span class="subst">$&#123;name&#125;</span>`</span>		<span class="comment">// 你好，hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>		<span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><ol>
<li><p>String.includes( str[, start] )</p>
<p> 返回布尔值，表示是否找到参数字符串。第二参数表示开始搜索位置。</p>
</li>
<li><p>String.startsWidth( str[, start])</p>
<p> 返回布尔值，表示参数字符串是否在源字符串的头部。第二参数表示开始搜索位置。</p>
</li>
<li><p>String.endsWidth( str[, start])</p>
<p> 返回布尔值，表示参数字符串是否在源字符串的尾部。第二参数表示开始搜索位置，特殊点是从开始到头部。</p>
</li>
<li><p>String.repeat( n )</p>
<p> 返回一个新字符串，表示将源字符串重复 n 次。小数会被向下取整。</p>
</li>
<li><p>String.padStart( length, str)</p>
<p> 用 str 头部补全目标字符串，默认 str 是空格，如果制定字符串最小长度 length 小于原字符串长度，则返回原字符串。</p>
</li>
<li><p>String.padEnd( length, str)</p>
</li>
</ol>
<h3 id="数值的拓展"><a href="#数值的拓展" class="headerlink" title="数值的拓展"></a>数值的拓展</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><p><code>ES6</code> 使用前缀 <code>0b(0B)</code> 表示二进制，<code>0o(0O)</code> 表示八进制。在严格模式下使用前缀 <code>0</code> 表示八进制会报错。</p>
<p>可以使用 <code>Number()</code> 方法将 其他进制转化为十进制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)		<span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h4 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h4><p>检查一个值是否为 <code>NaN</code> 。</p>
<h4 id="Number-parseInt-和-Number-parseFloat"><a href="#Number-parseInt-和-Number-parseFloat" class="headerlink" title="Number.parseInt() 和 Number.parseFloat()"></a>Number.parseInt() 和 Number.parseFloat()</h4><p><code>ES6</code> 将全局方法 <code>parseInt()</code> 和 <code>parseFloat()</code> 移植到 <code>Number</code> 对象上，行为不变，由于 <code>ES</code> 向上兼容，仍然可以使用全局的方法。</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>用来判断一个数是否为整数，在 <code>JS</code> 内部，整数和浮点数是同样的存储方法，所有 3 和 3.0 全等。</p>
<h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>极小常量 <code>2.220446049250313e-16</code> ，使用 <code>toFixed()</code> 方法保留 20 位小数后的值为 <code>0.00000000000000022204</code> 。</p>
<p>极小常量的实质是一个可以接受的误差范围，如果误差小于极小常量，我们就认为得到正确的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>)		<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>)		<span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt; <span class="built_in">Number</span>.EPSILON)		<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>其他的并不常用。</p>
<h3 id="函数的拓展"><a href="#函数的拓展" class="headerlink" title="函数的拓展"></a>函数的拓展</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>在 <code>ES6</code> 之前不能为函数的参数指定默认值，只能采用变通的办法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    y = y || <span class="string">'hello'</span>;		<span class="comment">// 先判断参数是否被赋值，如果没有再使其等于默认值。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体方法见解构赋值。</p>
<p>默认参数只能在参数列表尾部，不然这个参数无法省略。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>函数的 <code>length</code> 属性将返回第一个参数到第一个指定默认值的参数之间的所有参数个数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length		<span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">1</span></span>) </span>&#123;&#125;).length		<span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length		<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，<font color="red">参数会形成一个单独的作用域！！！</font>初始化结束后作用域消失。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>	<span class="comment">// 和函数中的 x 完全无关</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>)	<span class="comment">// y = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 y 的默认值等于变量 x，调用函数，参数 (x, y = x) 形成单独作用域，y 的默认值指向第一个参数 x，而不是全局的 x。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>	<span class="comment">// 如果不存在，报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(y, x)		<span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 y 的默认值等于变量 x，调用函数，参数 (y = x) 形成一个单独的作用域，x 没有声明，参数 x 会指向全局的 x，如果全局 x 未声明，则报错。</span></span><br><span class="line"><span class="comment">// 函数体内部声明的 x 不会影响到参数作用域中的 x，并且因为参数中未声明 x，函数体内的 x 声明不会报错！如果声明 y，则会因为参数中已经声明报错。</span></span><br></pre></td></tr></table></figure>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p><code>ES6</code> 引入<code>rest</code> 参数（<code>...变量名</code>） ，用于获取函数的多余参数，取代 <code>arguments</code> 类数组对象。该变量是一个数组，将多余的参数放入其中，函数中只能存在一个 <code>rest</code> 参数，并且只能放在参数尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...values 就是 rest 参数，values 是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> values)</span><br><span class="line">    sum += val</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)		<span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><code>ES6</code> 允许使用箭头 <code>=&gt;</code> 来定义函数。</p>
<p>箭头函数中，如果只有一个参数，可以只写参数名，不需要括号，如果没有参数，只需要写一个括号；如果函数体只有一条语句，可以省略大括号以及 <code>return</code>。如果 <code>return</code> 值是一个对象，需要在对象外加圆括号以示区分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缩写为箭头函数</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缩写为箭头函数</span></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>箭头函数的作用是简化回调函数，修改 <code>this</code>  指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>箭头函数体内的 <code>this</code> 对象就是定义时所在的对象，而不是使用时所在的对象。与一般的函数相反。</li>
<li>不可以当构造函数，也就是说不能使用 <code>new</code> 命令。</li>
<li>不可以使用 <code>arguments</code> 对象，必要时可以用 <code>rest</code> 参数代替。</li>
<li>不可以使用 <code>yield</code> 命令，不能作 <code>Generator</code> 函数。</li>
</ol>
<h5 id="this-理解"><a href="#this-理解" class="headerlink" title="this 理解"></a>this 理解</h5><p>箭头函数本身没有 <code>this</code> 对象，它继承自外层调用者，总是指向函数定义生效时所在的对象。</p>
<p><strong>扩展理解</strong>： 箭头函数的 this 看外层的是否有函数。如果有，外层函数的 this 就是内部箭头函数的 this ；如果没有，则 this 是 window 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例 1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  f1: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  f2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.f1()	<span class="comment">// windows</span></span><br><span class="line">obj.f2()	<span class="comment">// 调用时的对象 obj</span></span><br></pre></td></tr></table></figure>
<p>箭头函数常用于回调函数，用来获取外层函数的 <code>this</code> 。</p>
<h3 id="数组的拓展"><a href="#数组的拓展" class="headerlink" title="数组的拓展"></a>数组的拓展</h3><h4 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h4><p><code>...</code> 拓展运算符，它是函数 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数列表，直接打印输出是用空格分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])		<span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">foo(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])		<span class="comment">// 使用拓展运算符传入参数</span></span><br></pre></td></tr></table></figure>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ol>
<li><p>合并数组。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr = [...a, ...b, ...c]		<span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">a.push(...b)		<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与解构赋值结合生成数组。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b)		<span class="comment">// 1 [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串转数组。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">'hello'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)		<span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现将有 <code>Iterator</code> 接口的对象转化为真正的数组。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]])</span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]		<span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...map.values()]	<span class="comment">// ["one", "two", "three"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>用于将类似数组的对象和可遍历的对象转化为真正的数组。并且可以接收第二个参数，作用类似于 map 方法，将每个元素处理后放入返回的数组。</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>弥补数组构造函数 <code>Array()</code> 不足，将一组数值转换为数组。</p>
<p>构造函数 <code>Array()</code> 会因参数数量不同导致行为有差异。<code>Array.of()</code> 基本代替 <code>Array()</code> 和  <code>new Array()</code> ，行为统一，没有歧义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() 		<span class="comment">// 创建空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)		<span class="comment">// 创建空数组，长度为 3 。是[, , ,]，不是 [3]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>)		<span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>)		<span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p>修改当前数组，将数组指定位置的成员覆盖到其他位置，并返回当前数组。</p>
<p><code>Array.prototype.copyWithin(target, start = 0, end = this.length)</code> </p>
<ul>
<li>target：开始替换位置。</li>
<li>start：开始读取数据位置。</li>
<li>end：停止读取位置。</li>
</ul>
<h4 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h4><p>用于找出第一个符合条件的数组成员，参数是回调函数。<code>find()</code> 返回值时第一个符合条件的值，或者 <code>undefined</code> 没找到。<code>findIndex()</code> 返回第一个符合条件的下标，或者 <code>-1</code> 没找到。</p>
<p>可以识别 <code>NaN</code> ，弥补 <code>IndexOf()</code> 方法的不足。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> value &lt; <span class="number">0</span>)		<span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p>使用给定值填充数组。</p>
<p><code>Array.prototype.fill(value, start = 0, end = this.length6)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)		<span class="comment">// [7, 7, 7] 创建长度为 3 的数组，并全部填充数值 7</span></span><br></pre></td></tr></table></figure>
<h4 id="entries-、keys-、values"><a href="#entries-、keys-、values" class="headerlink" title="entries()、keys()、values()"></a>entries()、keys()、values()</h4><p>用于遍历数组。返回遍历器对象，可用 <code>for...of</code> 循环遍历，<code>keys()</code> 对键名的遍历，<code>values()</code> 对键名遍历，<code>entries()</code> 对键值对匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, value] <span class="keyword">of</span> arr.entries())</span><br><span class="line">  <span class="built_in">console</span>.log(index, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"><span class="comment">// 2 "c"</span></span><br></pre></td></tr></table></figure>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>返回一个布尔值，表示某个数组是否包含指定的值。并且可以辨别 <code>NaN</code> 类型。</p>
<p><code>Array.prototype.includes(value, start = 0)</code></p>
<h3 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h3><h4 id="属性和方法的简写"><a href="#属性和方法的简写" class="headerlink" title="属性和方法的简写"></a>属性和方法的简写</h4><p><code>ES6</code> 允许在对象中只写属性名，不写属性值，此时属性值等于属性名所代表的变量；方法可以省略 <code>: function</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'bar'</span> </span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// foo: foo</span></span><br><span class="line">  foo,</span><br><span class="line">  <span class="comment">// 方法缩写 </span></span><br><span class="line">  f() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 不缩写</span></span><br><span class="line">  f2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p><code>ES6</code> 允许两种形式定义对象的属性和方法，第一种就是常见的用标识符作属性名方法名，第二种就是用方括号加表达式作属性名方法名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'bar'</span> </span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 常见的标识符属性名</span></span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  <span class="comment">// ES6 的属性名表达式</span></span><br><span class="line">  [foo]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.name    <span class="comment">// 'hello'</span></span><br><span class="line">obj[foo]    <span class="comment">// 123，使用属性名表达式获取</span></span><br><span class="line">obj[<span class="string">'bar'</span>]  <span class="comment">// 123</span></span><br><span class="line">obj.bar     <span class="comment">// 123，使用标识符形式获取</span></span><br></pre></td></tr></table></figure>
<font color="red">注意：属性名表达式与简写形式不能同时使用，否则会报错。</font>

<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>用来比较两个值是否严格相等，与严格相等运算符 <code>===</code> 行为基本一致，并且 <code>+0</code> 不等于 <code>-0</code> ，<code>NaN</code> 等于自身。</p>
<p>相等运算符 <code>==</code> 会自动转化数据类型。</p>
<p>严格相等运算符 <code>===</code> <code>+0</code> 等于 <code>-0</code> ，<code>NaN</code> 不等于自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)		<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>用于将源对象的所有可枚举的自身属性浅复制到目标对象。</p>
<p><code>Object.assign(target, source[, source])</code> 第一个参数是目标对象，之后都是源对象，如果出现同名属性，后面的属性会覆盖前面的属性；如果参数不是对象，会转化成对象，无法转换时，如果在目标对象位置则报错，如果在源对象位置则跳过。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> s1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> s2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, s1, s2)</span><br><span class="line"></span><br><span class="line">target		<span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>只能复制可枚举属性，字符串类型可以复制，数值、布尔值无法复制。</li>
<li>只能复制源对象自身属性，继承属性不能复制。</li>
<li>实行浅复制，而不是深复制，如果源对象某个属性值是对象，那么只能复制这个对象的引用。 </li>
</ol>
<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h4><p><code>__proto__</code> 属性（前后各有两个下划线）用来读取或设置当前对象的 <code>prototype</code> 原型对象。<code>ES6</code> 规定只有浏览器必须部署这个属性，其他运行环境不一定要部署，而且最好认为这个属性不存在。</p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p>用于设置一个对象的 <code>prototype</code> 对象（原型对象）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 proto 对象</span></span><br><span class="line"><span class="keyword">let</span> proto = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 proto 为 obj 的原型对象</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto)</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span></span><br><span class="line">proto.z = <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><img src="/前端-JavaScript基础-EcamScript6/proto.JPG" alt="proto.JPG"></p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>用于获取一个对象的 <code>prototype</code> 对象（原型对象）。</p>
<h4 id="Object-create-1"><a href="#Object-create-1" class="headerlink" title="Object.create()"></a>Object.create()</h4><p><code>Object.create(proto, [propertiesObject])</code></p>
<p>用于创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p>
<h4 id="对象的拓展运算符与解构"><a href="#对象的拓展运算符与解构" class="headerlink" title="对象的拓展运算符与解构"></a>对象的拓展运算符与解构</h4><p><code>ES8</code> 中引用对象拓展符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)	<span class="comment">// 1 2 &#123;a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种方法相同</span></span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;</span><br><span class="line"><span class="keyword">let</span> n2 = <span class="built_in">Object</span>.assign(&#123;&#125;, z)</span><br></pre></td></tr></table></figure>
<h4 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h4><p>对象的解构和 <code>Object.assign()</code> 都是浅复制，如果想要完整克隆一个对象，还要复制对象原型的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.assgin(<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)), obj)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><p><code>Promise</code> 对象代表了未来某个时间将发生的事件，是一 个异步操作。</p>
<p>有了 <code>Promise</code> ，可以将异步操作以同步的流程表达出来，避免层层嵌套的回调函数（俗称 “回调地域”）。</p>
<h4 id="callback-hell-回调地狱"><a href="#callback-hell-回调地狱" class="headerlink" title="callback hell 回调地狱"></a>callback hell 回调地狱</h4><p><strong>回调</strong> 是作为参数传递给另一个函数的函数，在父函数完成后执行。被作为参数传递到另一个函数（主函数）的那个函数就叫做 <strong>回调函数</strong> 。</p>
<p>在 JS 程序中，程序执行不会等待异步操作执行，而异步操作的时 。 间长短与操作的内容有关，并不一定会按顺序。</p>
<p>如下代码，有三个读取文件的异步操作，其执行结束的顺序与文件大小及其他因素有关，所以控制台输出的结果顺序会不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./b.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./c.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果需要将这个程序按先后顺序执行，可以如下修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">  fs.readFile(<span class="string">'./b.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">    fs.readFile(<span class="string">'./c.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果有更多的异步操作，就需要在回调函数中不断地嵌套函数，代码深度将非常恐怖，也非常不利于维护，这就是<font color="red">回调地域</font>。</p>
<h4 id="Promise-含义"><a href="#Promise-含义" class="headerlink" title="Promise 含义"></a>Promise 含义</h4><p><code>Promise</code> 异步操作有三种状态：<code>pending（进行中）</code>、 <code>resolved（已定型） /fulfilled（已成功）</code> 和  <code>rejected（已失败）</code>。<code>Promise</code>对象只有：从 <code>pending</code> 变为 <code>Resolved</code> 和从 <code>pending</code> 变为 <code>rejected</code> 的状态改变。只要处于 <code>resolved</code> 和 <code>rejected</code> ，状态就不会再变了。</p>
<p><img src="/2019/08/01/前端-JavaScript基础-EcamScript6/Promise.jpg" alt="Promise.jpg"></p>
<p><code>Promise</code> 对象特点：</p>
<ul>
<li>状态不受外界影响。</li>
<li>一旦状态发生改变（已成功、已失败），任何时候都可以得到这个结果。</li>
</ul>
<p>优点:</p>
<ul>
<li>将异步操作以同步的流程表达出来，避免层层回调函数。</li>
<li><code>Promise</code> 对象提供统一接口，使得控制异步操作更容易。</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>Promise</code> 对象一旦新建就会被执行，中途无法被取消。</li>
<li>如果不设置回调函数， <code>Promise</code> 内部抛出的错误不会反应到外部。</li>
<li>过程中无法知道得知目前进展到那个一阶段。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise 对象的使用</span></span><br><span class="line"><span class="keyword">var</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 承诺任务失败，Pending 状态变成 Rejected</span></span><br><span class="line">    reject(err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 承诺任务完成，Pending 状态变成 Resolve</span></span><br><span class="line">    resolve(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 新建后会立即执行，它本身是同步操作，也就是说会立即执行 some code 部分，当前脚本所有同步任务执行完成之后才会执行 then 方法 。</span></span><br></pre></td></tr></table></figure>
<h4 id="then-、catch"><a href="#then-、catch" class="headerlink" title="then()、catch()"></a>then()、catch()</h4><p><code>then()</code> 方法接收两个回调函数作为参数，两个函数只会有一个被调用。</p>
<ul>
<li><p>第一个参数是 <code>Promise</code> 执行成功 <code>Resolve</code> 成功状态时的回调。</p>
</li>
<li><p>第二个参数是 <code>Promise</code> 执行失败 <code>Reject</code> 失败状态时的回调。建议使用 <code>catch()</code> 捕获。</p>
</li>
</ul>
<p><code>then()</code> 方法会在异步操作完成之后执行。</p>
<p><code>then()</code> 方法可以有返回值，返回一个新的 <code>Promise</code> 实例，用于链式调用异步操作。</p>
<p><code>catch()</code> 方法用于<font color="red">捕获之前发生出错误时的回调</font>。因为当 <code>then()</code> 方法中写两个回调时，如果链式调用比较多，那么代码将比较复杂，并且失败时代码基本相同，使用 <code>catch()</code> 方法捕获写起来更简单。</p>
<p><code>Promise</code> 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也就是说，错误总会被下一个 <code>catch()</code> 语句捕获，如果在 <code>catch()</code> 语句中发生错误……当前的 <code>catch()</code> 无法捕捉，需要下一个来捕捉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> p2</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>误区：</strong><code>catch()</code> 只能写在最后？<code>catch()</code> 只是捕获错误，<code>catch()</code> 和 <code>then()</code> 一样，返回值都是 <code>Promise</code> 对象，因此 <code>catch()</code> 之后可以继续调用 <code>then()</code> 。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>用于将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例，这个新的 <code>Promise</code> 实例和普通的 <code>Promise</code> 实例行为基本一致，唯一区别是只有当新的实例参数中的实例状态都变成成功时才成功，否则失败 。</p>
<p><code>Promise.all()</code> 的参数必须是具有 <code>Iterator</code> 接口，并且返回的每个成员都是 <code>Promise</code> 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br></pre></td></tr></table></figure>
<p>如果原先的 <code>Promise</code> 实例自身定义了 <code>catch</code> 方法，那么它 <code>rejected</code> 时并不会触发 <code>Promise.all()</code> 的 <code>catch()</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'正确'</span>, result))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'错误'</span>, err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确 ["hello", Error: 报错了]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码中，p1 会 resolved，p2 主动抛出错误，变成 rejected，被 p2 自身 catch 捕获，catch 返回结果也是 Promise 实例，p2 实际指向这个实例。该实例执行完 catch 之后也会变成 resolved，导致 Promise.all() 方法参数中两个实例都 resolved。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以，如果需要使用 Promise.all() 的 catch 方法，就不能在参数的 Promise 实例中设置 catch 捕获。</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>也是用于将多个 <code>Promise</code> 实例包装成新的 <code>Promise</code> 实例。与 <code>Promise.all()</code> 不同的是，<code>Promise.race()</code> 实例的参数实例中只要有一个改变状态，其状态就会改变。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>将对象装换为 <code>Promise</code> 对象，状态为 <code>resolved</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(obj))</span><br></pre></td></tr></table></figure>
<p>将对象作为 <code>resolve()</code> 的参数传入 。有已下四种情况。</p>
<ol>
<li><p>参数是 <code>Promise</code> 实例，原封不动返回。</p>
</li>
<li><p>参数是 <code>thenable</code> 对象（指具有 <code>then</code> 方法的对象）。将对象转化为 <code>Promise</code> 对象，并立即执行 <code>thenable</code>对象的  <code>then</code> 方法。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(obj)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)		<span class="comment">// 123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数对象不具有 <code>then</code> 方法或不是对象。返回一个新的 <code>Promise</code> 对象，状态为 <code>Resolved</code> ，并且 <code>Promise.resolve()</code> 的参数会同时传给回调函数。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'hello'</span>)		<span class="comment">// 传入一个字符串 </span></span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)	<span class="comment">// hello</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>无参数。会直接返回一个 <code>Resolved</code> 状态的 <code>Promise</code> 对象。</p>
</li>
</ol>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>将对象装换为 <code>Promise</code> 对象，状态为 <code>rejected</code> 。</p>
<p><code>Promise.reject()</code> 方法的参数会原封不动地作为 <code>reject</code> 的理由变成后续方法的参数。</p>
<h4 id="Promise-done"><a href="#Promise-done" class="headerlink" title="Promise.done()"></a>Promise.done()</h4><p><code>then()</code> 和 <code>catch()</code> 结尾的回调链只要最后一个方法抛出错误，就无法捕捉，<code>Promise.done()</code> 方法就是总是处于回调链尾端，保证抛出任何可能出现的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        	setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>)</span><br><span class="line">    	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .done()</span><br></pre></td></tr></table></figure>
<p><code>done()</code> 方法可以像 <code>then()</code> 方法那样，提供 <code>Resolved</code> 和 <code>Rejected</code> 状态的回调函数。但是不管怎样，<code>done</code> 方法都会捕捉到任何可能出现的错误，并向全局抛出。</p>
<h4 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h4><p><code>finally()</code> 方法不管 <code>Promise</code> 对象最后状态如何都会执行的操作。它与 <code>done()</code> 方法最大的区别在于，它接收一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">    .listen(<span class="number">0</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">	.finally(server.stop)</span><br></pre></td></tr></table></figure>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="案例：将函数封装成-Promise-对象"><a href="#案例：将函数封装成-Promise-对象" class="headerlink" title="案例：将函数封装成 Promise 对象"></a>案例：将函数封装成 <code>Promise</code> 对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="案例：Node-js-中-Promise-读取文件数据"><a href="#案例：Node-js-中-Promise-读取文件数据" class="headerlink" title="案例：Node.js 中 Promise 读取文件数据"></a>案例：Node.js 中 Promise 读取文件数据</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js 中多个异步操作依次执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 承诺任务失败，Pending 状态变成 Rejected</span></span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 承诺任务完成，Pending 状态变成 Resolve</span></span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./b.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 承诺任务失败，Pending 状态变成 Rejected</span></span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 承诺任务完成，Pending 状态变成 Resolve</span></span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./c.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 承诺任务失败，Pending 状态变成 Rejected</span></span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 承诺任务完成，Pending 状态变成 Resolve</span></span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">      <span class="keyword">return</span> p2</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文件读取失败，错误对象：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">      <span class="keyword">return</span> p3</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文件读取失败，错误对象：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文件读取失败，错误对象：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简化代码，可以将这个异步操作封装成 API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span> (<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filePath, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 承诺任务失败，Pending 状态变成 Rejected</span></span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 承诺任务完成，Pending 状态变成 Resolve</span></span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pReadFile(<span class="string">'./a.txt'</span>)</span><br><span class="line">  .then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">      <span class="keyword">return</span> pReadFile(<span class="string">'./b.txt'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文件读取失败，错误对象：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">      <span class="keyword">return</span> pReadFile(<span class="string">'./c.txt'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文件读取失败，错误对象：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文件读取失败，错误对象：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="案例：前端请求数据时的-Promise"><a href="#案例：前端请求数据时的-Promise" class="headerlink" title="案例：前端请求数据时的 Promise"></a>案例：前端请求数据时的 Promise</h5><p>这里使用 <code>ajax</code> 请求 <code>API</code> 数据时，有时会出现一个页面需要请求多个不同的 <code>API</code>，少则三五个，多则七八个，因彼此间有先后顺序，此时就需要保证异步请求的先后顺序了，<code>jQuery</code> 中已经支持了 <code>Promise</code>。</p>
<p>这个案例需要 <code>API</code> 数据，可以用 <code>json-server</code> 工具来模拟。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"user_form"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 模板内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; user.username &#125;&#125;"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; user.age &#125;&#125;"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>职业<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span></span><br><span class="line"><span class="undefined">                    &#123;&#123; each jobs&#125;&#125;</span></span><br><span class="line"><span class="javascript">                        &#123;&#123; <span class="keyword">if</span> user.jobId === $value.id&#125;&#125;</span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; $value.id &#125;&#125;"</span> <span class="attr">selected</span>&gt;</span>&#123;&#123; $value.name &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                        &#123;&#123; <span class="keyword">else</span> &#125;&#125;</span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; $value.id &#125;&#125;"</span>&gt;</span>&#123;&#123; $value.name &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                        &#123;&#123; /<span class="keyword">if</span> &#125;&#125;</span></span><br><span class="line"><span class="undefined">                    &#123;&#123; /each &#125;&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引用模板 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/art-template/lib/template-web.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引用 jQuery --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/jquery/dist/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 模板渲染 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">            /**</span></span><br><span class="line"><span class="undefined">             *  未用 promise</span></span><br><span class="line"><span class="undefined">             */</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">            promiseGet(<span class="string">"http://127.0.0.1:3000/users/4"</span>)</span></span><br><span class="line"><span class="javascript">                .then(<span class="function"><span class="params">userData</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">                    data.user = userData</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> promiseGet(<span class="string">"http://127.0.0.1:3000/jobs"</span>)</span></span><br><span class="line"><span class="undefined">                &#125;)</span></span><br><span class="line"><span class="javascript">                .then(<span class="function"><span class="params">jobsData</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">                    data.jobs = jobsData</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> htmlStr = template(<span class="string">"tpl"</span>, data)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.querySelector(<span class="string">"#user_form"</span>).innerHTML = htmlStr</span></span><br><span class="line"><span class="undefined">                &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            /**</span></span><br><span class="line"><span class="undefined">             *  使用 promise 的 jQuery</span></span><br><span class="line"><span class="undefined">             */</span></span><br><span class="line"><span class="javascript">            <span class="comment">// var data = &#123;&#125;;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// // userData，jobsData 返回时就是对象了</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// $.get("http://127.0.0.1:3000/users/4")</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     .then(userData =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         data.user = userData</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         return $.get("http://127.0.0.1:3000/jobs")</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     &#125;)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     .then(jobsData =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         data.jobs = jobsData</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         var htmlStr = template("tpl", data)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         document.querySelector("#user_form").innerHTML = htmlStr</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     &#125;)</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            /**</span></span><br><span class="line"><span class="undefined">             * 封装 ajax 获取网络请求的 promise 方法，可以再写个callback，就可以支持多重形式</span></span><br><span class="line"><span class="undefined">             **/</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">promiseGet</span>(<span class="params">url</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 当请求加载成功之后要调用的函数</span></span></span><br><span class="line"><span class="javascript">                    oReq.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        resolve(<span class="built_in">JSON</span>.parse(oReq.responseText));</span></span><br><span class="line"><span class="undefined">                    &#125;;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 当请求加载失败之后要调用的函数</span></span></span><br><span class="line"><span class="javascript">                    oReq.onerror = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">                        reject(err);</span></span><br><span class="line"><span class="undefined">                    &#125;;</span></span><br><span class="line"><span class="javascript">                    oReq.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">                    oReq.send();</span></span><br><span class="line"><span class="undefined">                &#125;);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// data.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"users"</span>:[</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"admin"</span>,<span class="attr">"age"</span>:<span class="number">28</span>,<span class="attr">"jobId"</span>:<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"username"</span>:<span class="string">"admin"</span>,<span class="attr">"age"</span>:<span class="number">28</span>,<span class="attr">"jobId"</span>:<span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">3</span>,<span class="attr">"username"</span>:<span class="string">"admin"</span>,<span class="attr">"age"</span>:<span class="number">28</span>,<span class="attr">"jobId"</span>:<span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">4</span>,<span class="attr">"username"</span>:<span class="string">"admin"</span>,<span class="attr">"age"</span>:<span class="number">28</span>,<span class="attr">"jobId"</span>:<span class="number">5</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"jobs"</span>:[</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"学生"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"老师"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">3</span>,<span class="attr">"name"</span>:<span class="string">"司机"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">4</span>,<span class="attr">"name"</span>:<span class="string">"画家"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">5</span>,<span class="attr">"name"</span>:<span class="string">"演员"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"id"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"电竞"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="案例：Node-js-调用-Mongoose-时的-promise"><a href="#案例：Node-js-调用-Mongoose-时的-promise" class="headerlink" title="案例：Node.js 调用 Mongoose 时的 promise"></a>案例：Node.js 调用 Mongoose 时的 promise</h5><p><code>mongoose</code> 所有 <code>API</code> 都支持 <code>promise</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">27017</span></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="keyword">const</span> dbName = <span class="string">'user'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 连接数据库</span></span><br><span class="line">mongoose.connect(<span class="string">`mongodb://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/<span class="subst">$&#123;dbName&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据库连接状态;</span></span><br><span class="line"><span class="keyword">var</span> db = mongoose.connection</span><br><span class="line">db.on(<span class="string">'error'</span>, <span class="built_in">console</span>.error.bind(<span class="built_in">console</span>, <span class="string">'数据库连接失败！'</span>))</span><br><span class="line">db.once(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// we're connected!</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数据库连接成功！'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Schema 文档结构设计（表结构）</span></span><br><span class="line"><span class="keyword">var</span> userSchema = mongoose.Schema(&#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="built_in">require</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="built_in">require</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  email: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="built_in">require</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  gender: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">    enum: [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 把 schema 编译成一个 Model，并返回 Model 对象</span></span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">'User'</span>, userSchema)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userJson = &#123;</span><br><span class="line">  username: <span class="string">'admin'</span>,</span><br><span class="line">  password: <span class="string">'1234'</span>,</span><br><span class="line">  email: <span class="string">'1234@qq.com'</span>,</span><br><span class="line">  age: <span class="number">17</span>,</span><br><span class="line">  gender: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mongoose 的 Promise，避免用户重复注册</span></span><br><span class="line">User.findOne(&#123; <span class="attr">username</span>: <span class="string">'admin'</span> &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="comment">// 查询成功的回调，data 为查找到的对象</span></span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户名已存在'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户名可用'</span>)</span><br><span class="line">        <span class="comment">// 用户不存在，注册</span></span><br><span class="line">        <span class="comment">// return 异步操作 save()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(userJson).save()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'数据查询失败'</span>)</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    <span class="comment">// 如果执行 save() 成功，data 返回的是保存的对象</span></span><br><span class="line">    <span class="comment">// 未执行 save() 方法，data 为空</span></span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据保存成功:'</span>, data)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据不保存'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'数据保存失败'</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 Promise</span></span><br><span class="line"><span class="comment">// User.findOne(&#123; username: 'admin' &#125;, (err, data) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   if (err) &#123;</span></span><br><span class="line"><span class="comment">//     return console.log('查询失败')</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   console.log('查找成功，data：', data)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   if (data) &#123;</span></span><br><span class="line"><span class="comment">//     console.log('用户名已存在')</span></span><br><span class="line"><span class="comment">//   &#125; else &#123;</span></span><br><span class="line"><span class="comment">//     console.log('用户名可用')</span></span><br><span class="line"><span class="comment">//     new User(userJson).save((err, data) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       if (err) &#123;</span></span><br><span class="line"><span class="comment">//         return console.log('保存失败')</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       console.log('保存成功，data：', data)</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>在 <code>ES6</code> 之前，<code>JS</code> 只有六种基本数据类型： <code>undefined</code> 、 <code>null</code> 、 <code>Boolean</code> 、 <code>String</code> 、 <code>Number</code> 、 <code>Object</code> ，在 <code>ES6</code> 中新增了一种基本数据类型 <code>Symbol</code> ，表示独一无二的值，避免字符串属性名造成的同名冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol 前不能使用 new 命令，它是数据类型，不是对象也不是构造函数。</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)		<span class="comment">// 传入一个字符串，表示对 Symbol 实例的标识，便于区分。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s 	<span class="comment">// symbol</span></span><br><span class="line">s			<span class="comment">// Symbol()</span></span><br><span class="line">s1			<span class="comment">// Symbol()</span></span><br><span class="line">s2			<span class="comment">// Symbol(foo)</span></span><br><span class="line">s == s1 	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li><code>Symbol</code> 属性对应的值是唯一的，解决命名冲突问题</li>
<li><code>Symbol</code> 值不能与其他数据进行计算，包括同字符串拼串</li>
<li><code>for in</code> , <code>for of</code> 遍历时不会遍历 <code>symbol</code> 属性。</li>
</ol>
<h4 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h4><p><code>Symbol</code> 作为对象属性名时不能使用点运算符的形式（obj.xxx)，因为点运算符后面需要跟字符串。所以只能用属性名表达式的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a[mySymbol] = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    [mySymbol]: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, [mySymbol], &#123; <span class="attr">value</span>: <span class="string">'hello'</span> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h4><p><code>Symbol</code> 作为属性名，该属性不能被 <code>for...in</code> 、<code>for...of</code> 遍历，也不能被 <code>Object.keys()</code> 、<code>Object.getOwnPropertyNames</code> 返回，可以被 <code>Object.getOwnPropertySymbols</code> 返回。</p>
<p>另一个 <code>Reflect.ownKeys()</code> 可以返回所有类型的键名，包括常规键和 <code>Symbol</code> 键名。</p>
<font color="red">以 Symbol 值作为名称的属性不会被常规方法遍历得到，我们可以利用这个特性为对象定义一些私有但又希望只用于内部的方法。</font>

<h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h4><p><code>Symbol.for()</code> 与 <code>Symbol()</code> 传入参数都会生成新的 <code>Symbol</code> ，区别是前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code> 使用时会先检查给定的参数键值是否存在，如果不存在会新建一个，存在则返回那个 <code>Symbol</code> 值。<code>Symbol()</code> 会直接新建一个新的 <code>Symbol</code> 值，并且不会登记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>)		<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'bar'</span>) === <span class="built_in">Symbol</span>(<span class="string">'bar'</span>)				<span class="comment">// false，存在两个不同的 Symbol(bar)</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h4><p>用于返回一个已登记的 <code>Symbol</code> 类型的 <code>key</code> ，不会创建 <code>Symbol</code> 值。与 <code>Symbol.for()</code> 可以配套使用。</p>
<h3 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a>Set 数据结构</h3><p><code>ES6</code> 提出的数据结构，类似于数组，但是成员的值是唯一的，没有重复。<code>Set</code> 本身是一个构造函数，接收一个有 <code>iterable</code> 接口的参数，用于生成 <code>Set</code> 数据结构。</p>
<p><code>Set</code> 内部判断采用 “Same-value equality” 同值相等算法，<code>Object.is()</code> ，<code>NaN</code> 类型会被去重。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])		<span class="comment">// 传入一个数组</span></span><br><span class="line"></span><br><span class="line">set  	<span class="comment">// [1, 2, 3, 4] 重复元素被删除</span></span><br></pre></td></tr></table></figure>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h4><ul>
<li><code>Set.prototype.size</code> ：返回 <code>Set</code> 实例的成员总数。</li>
<li><code>add()</code> ：添加某个值，返回 <code>Set</code> 结构本身。</li>
<li><code>delete()</code> ：删除某个值，返回布尔值，表示删除是否成功。</li>
<li><code>has()</code> ：返回一个布尔值，表示参数是否为 <code>Set</code> 成员。</li>
<li><code>clear()</code> ：清除所有成员。</li>
</ul>
<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p><code>Set</code> 结构有三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>keys()</code> ：返回键名的遍历器。<font color="red">Set 结构没有键名，或者说键名和键值是同一个值。所以 keys() 方法和 values() 方法完全</font></li>
<li><code>values()</code> ：返回键值的遍历器。默认遍历方法。</li>
<li><code>entries()</code> ：返回键值对的遍历器。</li>
<li><code>forEach()</code> ：使用回调函数遍历每个成员。可以传入第二参数绑定 <code>this</code> 。</li>
</ul>
<p><code>Set</code> 的遍历顺序就是插入顺序。</p>
<h3 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a>Map 数据结构</h3><p><code>JS</code> 对象本质是键值对的集合（Hash 结构），但是只能用字符串作为键，也就是说是 “字符串 - 值” 的对应。</p>
<p><code>Map</code> 数据结构是一种更完善的 Hash 结构，类似于对象，也是键值对的集合，但是键可以是任意类型，支持 “值 - 值” 的对应。</p>
<p><code>Map</code> 本身是一个构造函数，接收一个有 <code>iterable</code> 接口的参数，用于生成 <code>Map</code> 数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()			<span class="comment">// 创建 Map 数据结构</span></span><br><span class="line"><span class="keyword">let</span> myKey = &#123; <span class="attr">p</span>: <span class="string">'hello world'</span> &#125;	<span class="comment">// 创建对象</span></span><br><span class="line"></span><br><span class="line">map.set(myKey, <span class="string">'lalala'</span>)      <span class="comment">// 设置键值对</span></span><br><span class="line">map.get(myKey)                <span class="comment">// 获取键值对</span></span><br><span class="line"></span><br><span class="line">map.has(myKey)				<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `Map` 结构的 `set` 方法，设置键值对，键是一个对象，值是一个字符串，`Map` 中的键值对是对象数组的形式进行存储的。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/01/前端-JavaScript基础-EcamScript6/map.JPG" alt="map.JPG"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Map 的构造函数</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">map.size    <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>)     <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>)     <span class="comment">// "张三"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 构造函数的实质算法（数组）</span></span><br><span class="line"><span class="keyword">let</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/01/前端-JavaScript基础-EcamScript6/map2.JPG" alt="map2.JPG"></p>
<h4 id="Map-键的引用"><a href="#Map-键的引用" class="headerlink" title="Map 键的引用"></a>Map 键的引用</h4><p>只有对同一对象的引用，<code>Map</code> 结构才能将其视为同一个键。<code>Map</code> 的键实际上是和内存地址绑定的，只要内存地址不一样，就是两个不同的键。</p>
<p><code>Map</code> 如果对同一个键多次赋值，后面的值将会覆盖前面的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单类型</span></span><br><span class="line">map</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'111'</span>)</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">1</span>)    <span class="comment">// '222'，简单数据类型内容存储在地址中，严格相等时可以确定为同一对象的引用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂类型</span></span><br><span class="line">map</span><br><span class="line">  .set([<span class="string">'a'</span>], <span class="number">123</span>)</span><br><span class="line">  .set([<span class="string">'a'</span>], <span class="number">456</span>)</span><br><span class="line"></span><br><span class="line">map.get([<span class="string">'a'</span>])		<span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 两个 set 和一个 get 虽然内容一样，但是他们的实际地址不同，map 中存储的是指向三个不同地址。</span></span><br></pre></td></tr></table></figure>
<h4 id="Map-实例的属性和方法"><a href="#Map-实例的属性和方法" class="headerlink" title="Map 实例的属性和方法"></a>Map 实例的属性和方法</h4><ul>
<li><code>size</code> 属性：返回 <code>Map</code> 结构的成员数量。</li>
<li><code>set(key, value)</code> ：设置 <code>Map</code> 结构的键值对。</li>
<li><code>get(key)</code> ：读取 <code>key</code> 对应的键值。</li>
<li><code>has(key)</code> ：返回一个布尔值，表示某个键是否存在。</li>
<li><code>delete(key)</code> ：返回一个布尔值，表示删除某个键是否成功。</li>
<li><code>clear()</code> ：清除所有成员。</li>
</ul>
<h4 id="遍历操作-1"><a href="#遍历操作-1" class="headerlink" title="遍历操作"></a>遍历操作</h4><p><code>Map</code> 结构与 <code>Set</code> 类似，实例有三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>keys()</code> ：返回键名的遍历器。</li>
<li><code>values()</code> ：返回键值的遍历器。</li>
<li><code>entries()</code> ：返回键值对的遍历器。</li>
<li><code>forEach()</code> ：使用回调函数遍历每个成员。可以传入第二参数绑定 <code>this</code> 。</li>
</ul>
<p><code>Map</code> 的遍历顺序就是插入顺序。</p>
<h4 id="Map-与-其他数据类型转化"><a href="#Map-与-其他数据类型转化" class="headerlink" title="Map 与 其他数据类型转化"></a>Map 与 其他数据类型转化</h4><h5 id="Map-与数组互相转化"><a href="#Map-与数组互相转化" class="headerlink" title="Map 与数组互相转化"></a>Map 与数组互相转化</h5><p><code>Map</code> 转二维数组使用拓展运算符，数组转 <code>Map</code> 只要将二维数组作为参数传入构造函数即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'abc'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'def'</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map]		<span class="comment">// [[1, 'abc'], [2, 'def']]	二维数组</span></span><br></pre></td></tr></table></figure>
<h5 id="Map-与对象"><a href="#Map-与对象" class="headerlink" title="Map 与对象"></a>Map 与对象</h5><p>如果 <code>Map</code> 的所有键都是字符串，就可以转为对象。对象转 <code>Map</code> 没有限制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 转对象方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span> (<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> strMap)</span><br><span class="line">    obj[key] = value</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'abc'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'def'</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = strMapToObj(map)		<span class="comment">// &#123;name: "abc", title: "def"&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象转 Map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))</span><br><span class="line">    strMap.set(key, obj[key])</span><br><span class="line">  <span class="keyword">return</span> strMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = objToStrMap(&#123;<span class="attr">name</span>: <span class="string">"abc"</span>, <span class="attr">title</span>: <span class="string">"def"</span>&#125;)		<span class="comment">// Map &#123;"name": "abc", "title": "def"&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="Map-与-JSON"><a href="#Map-与-JSON" class="headerlink" title="Map 与 JSON"></a>Map 与 JSON</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 转 JSON </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Map 的键名都是字符串，可以转为对象 JSON，结合 strMapToObj() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span> (<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Map 的键名不是字符串，可以转为数组 JSON</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON 转 Map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span> (<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Iterator-和-for-…-of-循环"><a href="#Iterator-和-for-…-of-循环" class="headerlink" title="Iterator 和 for … of 循环"></a>Iterator 和 for … of 循环</h3><p><code>Iterator</code> 遍历器是一个接口，为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署 <code>Iterator</code> 接口就可以实现遍历操作。</p>
<p><code>Iterator</code> 作用：</p>
<ol>
<li>为各种数据结构提供一个统一的、简便的访问接口。</li>
<li>使得数据结构的成员能够按照某种次序排列。</li>
<li><code>ES6</code> 创造一种新的遍历命令—— <code>for...of</code> 循环。</li>
</ol>
<p><code>Iterator</code> 遍历过程：</p>
<ol>
<li><p>创建一个指针对象，指向当前数据结构的起始位置。</p>
</li>
<li><p>第一次调用指针对象的 <code>next</code> 方法，可以将指针指向数据结构的第一个成员。</p>
</li>
<li><p>第二次调用指针对象的 <code>next</code> 方法，指针就指向数据结构的第二个成员。</p>
</li>
<li><p>不断调用指针对象的 <code>next</code> 方法，直到它指向数据结构的结束位置。</p>
</li>
</ol>
<p>每次调用 <code>next</code> 方法都会返回数据结构的当前成员信息。具体来说，就是返回一个包含 <code>value</code> 和 <code>done</code> 两个属性的对象。<code>value</code> 是当前成员的值，<code>done</code> 是一个布尔值，表示遍历是否结束。</p>
<h4 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h4><p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 <code>iterator</code> 接口，就可以用 <code>for ... of</code> 循环遍历它的成员，也就是说 <code>for ... of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。   </p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组原生具备 <code>iterator</code> 接口，默认部署 <code>Symbol.iterator</code> 属性。</p>
<p><code>for ... of</code> 循环可以代替数组实例的 <code>forEach</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element, index)</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// for...of 循环允许遍历获得键值，或者使用 entries 之类遍历器对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, element] <span class="keyword">of</span> arr.entries())</span><br><span class="line">  <span class="built_in">console</span>.log(index, element)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in 只能获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr)</span><br><span class="line">  <span class="built_in">console</span>.log(index)</span><br></pre></td></tr></table></figure>
<h5 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set / Map"></a>Set / Map</h5><p>见具体章节。</p>
<p>遍历顺序按照各个成员被添加进数据结构的顺序。</p>
<p><code>Set</code> 结构遍历时返回的第一个值，而 <code>Map</code> 返回的是一个数组，数组的两个成员分别是键名和键值。</p>
<h5 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h5><p>像字符串、DOM、arguments 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str)</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br></pre></td></tr></table></figure>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>普通的对象 <code>for ... of</code> 不能直接使用，必须部署了 <code>Iterator</code> 接口才行。但是 <code>for ... in</code> 可以用于遍历键名。</p>
<p>可以用 <code>Object.keys</code> 将对象的键名生成一个数组，然后用 <code>for ... of</code> 遍历数组。</p>
<h3 id="Class-（类）"><a href="#Class-（类）" class="headerlink" title="Class （类）"></a>Class （类）</h3><p><code>ES6</code> 引入 <code>Class (类)</code> 的概念作为对象的模板，通过 <code>class</code> 关键字可以定义类，与传统的面向对象语言类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 类和对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.toString())		<span class="comment">// (1, 2)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 类和对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.toString())		<span class="comment">// (1, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point 		<span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor 		<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的数据类型是函数，类本身指向构造函数。</span></span><br></pre></td></tr></table></figure>
<font color="red">注意：定义类的内部方法时，前面不需要 function 保留字，方法之间不需要逗号分隔。</font>

<p>事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上。在类的实例上调用方法其实就是调用原型上的方法。可以使用 <code>Object.assign</code> 方法向类添加属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Point()</span><br><span class="line"></span><br><span class="line">p.constructor = Point.prototype.constructor		<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h4><p>类和模块的内部默认使用严格模式，所以不需要使用 <code>use strict</code> 指定运行模式。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>constructor</code> 构造函数是类的默认方法，通过 <code>new</code> 命令生成对象实例时自动调用的方法。一个类必定会有构造函数，如果没有显示定义，会自动创建一个空的构造函数。</p>
<h4 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h4><p>注意点：</p>
<ul>
<li><p>生成实例需要使用 <code>new</code> 命令。</p>
</li>
<li><p>实例（如 point）的属性除非显示定义在其本身（<code>this</code> 对象）上，否则都是定义在原型上（对象 Point）。类的所有实例共享一个原型对象（即类本身）。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">point.toString()    <span class="comment">// (2, 3)</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>)       <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>)       <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>)       <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>)       <span class="comment">// true </span></span><br><span class="line">point.__proto__.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;	<span class="comment">// 在原型上添加方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x, y 显示定义在 this 变量上，hasOwnProperty() 可以获取对象自身的属性，x, y 返回 true ，而 toString() 方法是定义在原型上的（Point类上，不是实例 point 上），所以返回 false。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h4><p>因为 <code>class</code> 的类型是 <code>function</code> ，所以一般函数的使用方法类都可以使用。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class 表达式，同函数表达式</span></span><br><span class="line"><span class="keyword">let</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如上，定义类后直接赋值给 MyClass。此时 Me，只能在 Class 内部使用，指代当前类，MyClass 才是真正的类名。</span></span><br></pre></td></tr></table></figure>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>类不存在变量提升，这是为了保证继承的可行性，必须保证子类在父类后定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如上，先定义父类再定义子类继承父类。</span></span><br><span class="line"><span class="comment">// 如果 class 存在变量提升，class 提升到代码头部，而 let 不提升，导致 Bar 继承 Foo 时，Foo 还没有定义。</span></span><br></pre></td></tr></table></figure>
<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p><code>ES6</code> 不提供私有方法。需要通过变通方法来模拟。</p>
<ol>
<li><p>前置下划线。人为约定，不保险，外部仍然可以访问。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共有方法</span></span><br><span class="line">  foo (x) &#123;</span><br><span class="line">    <span class="keyword">this</span>._bar(x)</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar (y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  foo (x) &#123;</span><br><span class="line">    bar.call(this, x)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function bar (y) &#123;</span><br><span class="line">  return this.snaf = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Symbol</code> 值唯一性，将私有方法命名为 <code>Symbol</code> 值。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>)</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (x) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz)</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar] (y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p><code>ES6</code> 同样也不支持私有属性。<font color="red">目前有一个提案，在属性名前使用 # 来表示类的私有属性和方法。</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂时没有用，还是提案，没有正式规定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  #x = 0</span><br><span class="line"></span><br><span class="line">  get x() &#123;</span><br><span class="line">    return #x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h4><p>类的方法内部的 <code>this</code> 默认指向类的实例。但是如果将方法提取出来，就会指向运行时所在的环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  printName (name = <span class="string">'AI'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.print (<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print (text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger = <span class="keyword">new</span> Logger()</span><br><span class="line">logger.printName()    <span class="comment">// hello AI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法取出</span></span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger </span><br><span class="line"></span><br><span class="line">printName()   <span class="comment">// Cannot read property 'print' of undefined</span></span><br></pre></td></tr></table></figure>
<p>如果要解决上面出现的错误，有三种方法。</p>
<ol>
<li><p>在构造函数中使用 <code>bind</code> 绑定 <code>this</code> 。此时 <code>printName</code> 就会绑定实例。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在构造函数中使用箭头函数定义方法。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'AI'</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.print (<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print (text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Proxy</code> ，在获取方法的时候自动绑定 <code>this</code> 。</p>
</li>
</ol>
<h4 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h4><p>在类的内部可以使用 <code>get</code> 和 <code>set</code> 关键字对某个属性设置存值函数和取值函数。都设置在 <code>Descriptor</code> 对象上。</p>
<p>有些迷。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>类相当于实例的原型，所以在类中定义的方法都会被实例继承，如果在一个方法前加 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类调用，称为<strong>静态方法</strong>。</p>
<p>静态方法是定义在类上的，而不是原型对象上。普通方法是定义在原型对象上的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.foo()   <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> MyClass()</span><br><span class="line">a.foo()   <span class="comment">// TypeError: a.foo is not a function</span></span><br></pre></td></tr></table></figure>
<p>父类的静态方法可以被子类继承，子类也可以使用 <code>super</code> 关键字获取父类的静态方法。</p>
<h4 id="静态属性和实例属性"><a href="#静态属性和实例属性" class="headerlink" title="静态属性和实例属性"></a>静态属性和实例属性</h4><p>静态属性是 <code>Class</code> 本身的属性，即 <code>Class.propname</code> ，通过类名调用的属性。</p>
<p>实例属性是实例对象 <code>this</code> 上的属性，即 <code>new Class().propname</code> ，通过对象实例调用的属性。</p>
<p><code>ES6</code> 明文规定，<code>Class</code> <strong>内部</strong>只有静态方法，没有静态属性。静态属性需要写在 <code>Class</code> 外部，实例属性写在 <code>Class</code> 内部。</p>
<font color="red">现在有一个提案提供了类的静态属性，写法是在实例属性法的前面，加上 static 关键字。</font>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 提案新规定，可用，但 ES6 未正式允许</span></span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.prop = <span class="number">1</span>   <span class="comment">// 添加静态属性，这种方式容易让人忽视这个静态属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> MyClass()</span><br><span class="line"><span class="built_in">console</span>.log(a.prop)     <span class="comment">// undefined，实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(MyClass.prop)		<span class="comment">// 1，静态属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  prop = <span class="number">2</span></span><br><span class="line">  prop2</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.prop2 = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.prop = <span class="number">1</span>   <span class="comment">// 添加静态属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> MyClass()</span><br><span class="line"><span class="built_in">console</span>.log(a.prop, a.prop2)     <span class="comment">// 2 3， 实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(MyClass.prop)		<span class="comment">// 1，静态属性</span></span><br></pre></td></tr></table></figure>
<h3 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h3><p><code>Class</code> 的继承通过 <code>extends</code> 关键字实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y)		<span class="comment">// 用 super 方法新建父类的 this 对象</span></span><br><span class="line">    <span class="keyword">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">', '</span> + <span class="keyword">super</span>.toString()		<span class="comment">// 通过 super 对象调用父类方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'red'</span>) </span><br><span class="line"><span class="built_in">console</span>.log(cp.toString())		<span class="comment">// red, 1, 2</span></span><br></pre></td></tr></table></figure>
<p>子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，需要使用 <code>super()</code> 方法调用父类的构造函数来创建父类的 <code>this</code> 对象，否则会报错。</p>
<p><code>ES6</code> 的<strong>继承机制</strong>是先创建父类的实例对象 <code>this</code> ，然后再调用子类的构造函数修改 <code>this</code> 。</p>
<p>如果子类没有显示定义构造函数，构造函数和 <code>super()</code> 调用父类构造函数都会被默认添加。 </p>
<h4 id="Object-getPrototypeOf-1"><a href="#Object-getPrototypeOf-1" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>获取对象的原型对象，子类继承父类，子类的原型对象就是父类，可以用这个方法来进行获取。</p>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p><code>super</code> 关键字既可以当函数又可以当对象。</p>
<ul>
<li><p><code>super</code> 作为函数时。</p>
<p>  在子类中代表父类的构造函数，在子类的构造函数用生成父类实例，获取父类实例对象的 <code>this</code> ，并转换成子类的 <code>this</code> 对象。并且只能在子类的构造函数一开始的地方使用，不然会报错。</p>
</li>
<li><p><code>super</code> 作为对象时。</p>
<ol>
<li><p><code>super</code> 作为对象时在普通方法中指向父类的原型对象 <code>Class.prototype</code> </p>
<p>由于 <code>super</code> 指向父类的对象，所以定义在父类实例上的方法或属性是无法通过 <code>super</code> 调用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()     <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p())    <span class="comment">// super 对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br></pre></td></tr></table></figure>
<p>通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的 <code>this</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print()		<span class="comment">// 调用父类的方法，此时方法中的 this 指向子类，相当于 super.print.call(this)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line">b.m()		<span class="comment">// 2 ，而不是 1</span></span><br></pre></td></tr></table></figure>
<p>当通过 <code>super</code> 对某个属性赋值时，此时 <code>super</code> 就是 <code>this</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">5</span>      <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">10</span>      <span class="comment">// 实例属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype.x = <span class="number">1</span>       <span class="comment">// 原型属性</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span></span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>     <span class="comment">// 赋值时 super 就是 this，指向 B 的实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x)      <span class="comment">// 1，获取原型属性中的 x</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)       <span class="comment">// 3，获取实例属性 x</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__.x)      <span class="comment">// 1，获取 b 实例原型属性 x，继承自 A</span></span><br><span class="line"><span class="built_in">console</span>.log(B.x)      <span class="comment">// 5，获取 B 的静态属性，继承自 A</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在静态方法中指向父类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> foo(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> foo(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo(msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.foo(<span class="number">1</span>)		<span class="comment">// static 1，静态方法指向父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B()</span><br><span class="line">b.foo(<span class="number">2</span>)		<span class="comment">// instance 2，普通方法指向父类的原型对象，因为普通方法是定义有原型对象上的。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和 __proto__ 属性"></a>类的 prototype 属性和 <code>__proto__</code> 属性</h4><p><code>Class</code> 作为构造函数的语法糖，同时有 <code>prototype</code> 和 <code>__proto__</code> 属性，因此同时存在两条继承链。</p>
<ol>
<li>子类的 <code>__proto__</code> 属性表示构造函数的继承，总是指向父类。</li>
<li>子类的 <code>prototype</code> 属性的 <code>__proto__</code> 属性表示方法的继承，总是指向父类的 <code>prototype</code> 属性。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A		<span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype		<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>在 <code>ES6</code> 之前的模块加载方案主要有 <code>CommonJS</code> 和 <code>AMD</code> 两种，前者用于服务器，后者用于浏览器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists</span><br><span class="line"><span class="keyword">let</span> readFile = _fs.readFile</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码的实质是整体加载 fs 模块，即加载模块的所有方法生成一个 `_fs` 对象然后再从这个对象上面读取指定方法。这种加载称为 “运行时加载”，因为只有运行时才能得到这个对象，导致完全没有办法在编译时进行 “静态优化”。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码的实质是从 fs 模块加载三个方法，而不加载其他方法。这种加载称为 "编译时加载" 或 “静态加载”，效率较高。</span></span><br></pre></td></tr></table></figure>
<p><code>ES6</code> 模块与 <code>CommonJS</code> 模块的差异：</p>
<ul>
<li><p><code>CommonJS</code> 模块输出的是一个值的复制，<code>ES6</code> 模块输出的是值的引用。</p>
</li>
<li><p><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时加载。</p>
<p>  <code>CommonJS</code> 加载的是一个对象（即 <code>module.exports</code> 属性），该对象只有在脚本运行结束时才会生成。而 <code>ES6</code> 模块不是对象，它的接口只是一种静态定义，在代码静态解析阶段生成。</p>
</li>
</ul>
<h4 id="严格模式-2"><a href="#严格模式-2" class="headerlink" title="严格模式"></a>严格模式</h4><p><code>ES6</code> 模块自动采用严格模式。</p>
<p>严格模式主要有以下限制：</p>
<ul>
<li>变量必须声明再使用。</li>
<li>函数函数不能有同名属性。</li>
<li>不能使用 <code>with</code> 语句。</li>
<li>不能对只读属性赋值。</li>
<li>不能使用前缀 0 表示八进制。</li>
<li>不能删除不可删除的属性。</li>
<li>不能删除变量 <code>delete</code> ，<code>prop</code> 。</li>
<li><code>eval</code> 不会在它的外层作用域引用变量。</li>
<li><code>eval</code> 和 <code>arguments</code> 不能被重新复制。</li>
<li><code>arguments</code> 不会自动反应函数参数的变化。</li>
<li>不能使用 <code>arguments.callee</code> 。</li>
<li>不能使用 <code>arguments.caller</code> 。</li>
<li>禁止 <code>this</code> 指向全局对象。</li>
<li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈。</li>
<li>增加了保留字。</li>
</ul>
<h4 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h4><p>模块功能只要由两个命令构成：<code>export</code> 和 <code>import</code> 。<code>export</code> 命令用于规定模块的对外接口， <code>import</code> 命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件，该文件内部所有的变量外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1897</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法，推荐写法</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span> </span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1897</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, lastName &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个名为 xxx.js 的模块，导出三个变量。</span></span><br></pre></td></tr></table></figure>
<p><code>export</code> 也可以输出函数或类。通常情况下， <code>export</code> 输出的变量就是本来的名字，但是可以使用 <code>as</code> 关键字重命名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; </span><br><span class="line">  v1,   <span class="comment">// 默认输出</span></span><br><span class="line">  v2 <span class="keyword">as</span> streamV2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>export</code> 语句输出的接口与其对应的值时动态绑定的，即能通过该接口可以取到模块内部实时的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始输出变量 foo 值为 bar，200ms 后变成 baz</span></span><br></pre></td></tr></table></figure>
<p><code>export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以，如果在块级作用域内，会报错。</p>
<h4 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h4><p><code>export default</code> 命令是模块的默认输出，一个模块只能有一个默认输出，<code>export default</code> 命令只能使用一次，对于这种情况的 <code>import</code> 可以不使用大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'xxx'</span></span><br><span class="line"><span class="comment">// import &#123; foo &#125; from 'xxx'</span></span><br></pre></td></tr></table></figure>
<p><code>export default</code> 命令其实只是输出一个叫做 <code>default</code> 的变量，后面不能接声明语句。可以直接接一个数值或者另一个已声明的变量，如果是一个已声明的变量，是将这个变量赋值给 <code>default</code> 之后再导出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> defalut a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> defalut <span class="number">24</span></span><br></pre></td></tr></table></figure>
<h4 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h4><p>使用 <code>export</code> 命令定义了模块的对外接口以后，其他 <code>JS</code> 文件就可以通过 <code>ipmort</code> 命令加载模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, lastName &#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要修改名字，可以使用 as 关键字，后缀名也可以省略</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName <span class="keyword">as</span> fn &#125; <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./xxx'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br></pre></td></tr></table></figure>
<p><code>import</code> 有提升效果，会吗命令提升到文件头部，并且重复执行同一句 <code>import</code> 无效，只能执行一次。</p>
<h4 id="export-和-import-复合写法"><a href="#export-和-import-复合写法" class="headerlink" title="export 和 import  复合写法"></a>export 和 import  复合写法</h4><p>如果一个模块之中先输入后输出同一个模块，<code>import</code> 和 <code>export</code> 语句可以写在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Node-加载"><a href="#Node-加载" class="headerlink" title="Node 加载"></a>Node 加载</h4><p><code>Node</code> 有自己的 <code>CommonJS</code> 模块格式，与 <code>ES6</code> 兼容，目前的解决方案是将两者分开，<code>ES6</code> 和 <code>CommonJS</code> 采用各自的加载方法。</p>
<p>在静态分析阶段，一个模块脚本只要有一行 <code>import</code> 或 <code>export</code> 语句，<code>Node</code> 就会认为该脚本为 <code>ES6</code> 模块，否则就是 <code>CommonJS</code> 模块。如果不希望输出任何接口，但是希望被 <code>Node</code> 认为是 <code>ES6</code> 模块，可以在脚本加上如下语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; &#125;		<span class="comment">// 表示不输出任何接口的 ES6 写法，不是输出空对象。</span></span><br></pre></td></tr></table></figure>
<p>如果不指定绝对路径，<code>Node</code> 加载 <code>ES6</code> 模块会依次寻找以下脚本，与 <code>require()</code> 规则一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./foo'</span></span><br><span class="line"><span class="comment">// 依次寻找</span></span><br><span class="line"><span class="comment">// ./foo.js</span></span><br><span class="line"><span class="comment">// ./foo/package.json</span></span><br><span class="line"><span class="comment">// ./foo/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'baz'</span></span><br><span class="line"><span class="comment">// 依次寻找</span></span><br><span class="line"><span class="comment">// ./node_modules/baz.js</span></span><br><span class="line"><span class="comment">// ./node_modules/baz/package.json</span></span><br><span class="line"><span class="comment">// ./node_modules/baz/index.js</span></span><br><span class="line"><span class="comment">// 寻找上一级目录</span></span><br><span class="line"><span class="comment">// ../node_modules/baz.js</span></span><br><span class="line"><span class="comment">// ../node_modules/baz/package.json</span></span><br><span class="line"><span class="comment">// ../node_modules/baz/index.js</span></span><br></pre></td></tr></table></figure>
<h5 id="import-命令加载-CommonJS-模块"><a href="#import-命令加载-CommonJS-模块" class="headerlink" title="import 命令加载 CommonJS 模块"></a>import 命令加载 CommonJS 模块</h5><p><code>CommonJS</code> 模块的输出都定义在 <code>module.exports</code> 属性上。在 <code>import</code> 命令加载 <code>CommonJS</code> 模块， <code>Node</code> 会自动将 <code>module.exports</code> 属性当做模块的默认输出，即等同于 <code>export default</code> 。</p>
<h5 id="require-命令加载-ES6-模块"><a href="#require-命令加载-ES6-模块" class="headerlink" title="require 命令加载 ES6 模块"></a>require 命令加载 ES6 模块</h5><p>采用 <code>require</code> 命令加载 <code>ES6</code> 模块时， <code>ES6</code> 模块的所有输出接口都会成为输入对象的属性。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="、-、Object-is"><a href="#、-、Object-is" class="headerlink" title="== 、===、Object.is()"></a>== 、===、Object.is()</h3><p>都表示相等。</p>
<ul>
<li><code>==</code> ：相等运算符，会自动转化数据类型后判断相等。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> == <span class="number">-0</span>		<span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>		<span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>		<span class="comment">// true</span></span><br><span class="line"><span class="string">"1"</span> == <span class="number">1</span>		<span class="comment">// true</span></span><br><span class="line">&#123;&#125; == &#123;&#125;		<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>===</code> ：严格相等运算符，需要判断类型和值是否相等。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>		<span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>		<span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>		<span class="comment">// false</span></span><br><span class="line">&#123;&#125; === &#123;&#125;		<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Object.is()</code> </li>
</ul>
<p>与严格相等运算符行为基本一致，使用 “Same-value equality” 同值相等算法，在任何环境中，只要两个值一样，就相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)		<span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)		<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>已知有一个数组 <code>let s = [1, 2, 2, 3, 3, 4, 4]</code> ，要求去重。</p>
<h4 id="Set-拓展运算符"><a href="#Set-拓展运算符" class="headerlink" title="Set + 拓展运算符"></a>Set + 拓展运算符</h4><p>拓展运算符内部采用 <code>for...of</code> 循环，可以用于 <code>Set</code> 结构。</p>
<p>利用 <code>Set</code> 成员唯一的特性，将原数组过滤后，使用拓展运算符展开传进数组，并修改原数组的指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">s = [...new <span class="built_in">Set</span>(s)]		<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h4 id="Set-Array-from"><a href="#Set-Array-from" class="headerlink" title="Set + Array.from()"></a>Set + Array.from()</h4><p><code>Array.from()</code> 可以将类数组结构或可遍历结构转化为数组。</p>
<p>利用 <code>Set</code> 成员唯一的特性，将原数组过滤后，将 <code>set</code> 传入 <code>Array.from()</code> 生成新数组，并修改原数组的指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">s = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(s))		<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组交并集"><a href="#数组交并集" class="headerlink" title="数组交并集"></a>数组交并集</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ..b])		<span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter (<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)))		<span class="comment">// Set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter (<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)))	<span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>见独立章节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/01/前端-JavaScript基础-EcamScript6/" data-id="cjzrwg7z5006tcgutw0vf1adv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EcamScript6/">EcamScript6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/22/前端-JavaScript基础-原型与原型链/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          前端-JavaScript基础-原型与原型链
        
      </div>
    </a>
  
  
    <a href="/2019/07/13/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECharts/">ECharts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EcamScript6/">EcamScript6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html-Css/">Html/Css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器兼容/">浏览器兼容</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件配置/">软件配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 19px;">Android</a> <a href="/tags/BOM/" style="font-size: 10px;">BOM</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/DOM/" style="font-size: 10px;">DOM</a> <a href="/tags/ECharts/" style="font-size: 10px;">ECharts</a> <a href="/tags/EcamScript6/" style="font-size: 11px;">EcamScript6</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Html-Css/" style="font-size: 11px;">Html/Css</a> <a href="/tags/JavaScript/" style="font-size: 18px;">JavaScript</a> <a href="/tags/Node/" style="font-size: 14px;">Node</a> <a href="/tags/Python/" style="font-size: 17px;">Python</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/blog/" style="font-size: 11px;">blog</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/前端/" style="font-size: 19px;">前端</a> <a href="/tags/后端/" style="font-size: 13px;">后端</a> <a href="/tags/小程序/" style="font-size: 10px;">小程序</a> <a href="/tags/数据库/" style="font-size: 12px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/框架/" style="font-size: 16px;">框架</a> <a href="/tags/浏览器兼容/" style="font-size: 10px;">浏览器兼容</a> <a href="/tags/移动端/" style="font-size: 20px;">移动端</a> <a href="/tags/软件配置/" style="font-size: 10px;">软件配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/25/框架-深入了解vuejs/">框架-深入了解vue.js</a>
          </li>
        
          <li>
            <a href="/2019/08/22/前端-JavaScript基础-原型与原型链/">前端-JavaScript基础-原型与原型链</a>
          </li>
        
          <li>
            <a href="/2019/08/01/前端-JavaScript基础-EcamScript6/">前端-JavaScript基础-二刷ES</a>
          </li>
        
          <li>
            <a href="/2019/07/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/07/12/前端-CSS预处理器/">前端-CSS预处理器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Ai Junhao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>